# 04. 카프카 컨슈머  


## 목표  

- <a href="#컨슈머_내부구조">카프카 컨슈머 내부 구조</a>
- <a href="#컨슈머_API">카프카 컨슈머 API</a>
- <a href="">자바 카프카 컨슈머 예제</a>
- <a href="">스칼라 컨슈머 예제</a>
- <a href="">일반적인 메시지 사용 유형</a>
- <a href="">모범 사례</a>  

---  

<div id="컨슈머_내부구조"></div>

> ### 카프카 컨슈머 내부 구조  

=> 카프카 큐에서 메시지 사용은 다른 메시징 시스템과 차이가 있지만, 컨슈머 API를 사용하여  
작성할 때는 대부분의 세부 사항이 추상화 됨  

**카프카 컨슈머의 역할 이해**  

- **토픽 구독하기**  
; 컨슈머 동작은 토픽을 구독하면서 시작  
=> 컨슈머가 컨슈머 그룹의 일부인 경우, 해당 토픽의 파티션 하부 세트가 할당  
- **컨슈머 오프셋 위치**  
; 카프카는 다른 큐와는 다르게 메시지 오프셋을 보유하지 않음  
=> 모든 컨슈머는 자신의 오프셋을 유지 할 책임을 가짐  
=> 컨슈머 오프셋은 컨슈머 API를 사용해 유지 됨  
(오프셋을 커밋하는 커스텀 로직 작성도 가능)  
- **재연/되감기(rewind)/메시지 스킵(skip)**  
; 카프카 컨슈머는 토픽 파티션에서 메시지를 읽는 시작점의 오프셋에 대한 전체적인 제어권을 가짐  
- **하트비트(heartbeat)**  
; 지정된 파티션의 멤버십과 소유권을 확인하기 위해 카프카 브로커(컨슈머 그룹 리더)로 하트비트  
신호를 주기적으로 보내는 것은 컨슈머가 책임지는 역할  
=> 정해진 시간 간격으로 그룹 리더가 하트비트를 수신하지 못하면, 파티션 소유권은 컨슈머 그룹 안의  
다른 컨슈머에게 다시 할당  
- **오프셋 커밋**  
;카프카 컨슈머 애플리케이션이 읽는 메시지의 위치나 오프셋을 관리하지 않음  
=> 자신의 파티션 오프셋과 커밋을 관리하는 것은 컨슈머 애플리케이션의 역할  
장점1) 개별 컨슈머 오프셋을 관리하지 않으므로 브로커 성능 향상  
장점2) 컨슈머 APP 특정 시나리오에 맞게 자신의 오프셋을 관리하는 유연성을 갖음  
=> 배치 처리를 마치면서 오프셋을 커밋할 수 있고, 매우 큰 배치를 처리하는 중간에도  
리밸런스(rebalance) 부작용을 줄이기 위해 오프셋을 커밋할 수 있음  
- **역직렬화 deserialization**  
; 카프카 프로듀서는 바이트 배열로 객체를 직렬화  
=> 카프카 컨슈머는 객체를 바이트 배열로 역 직렬화  

![컨슈머 흐름](./pics/04_01_consumer.png)   


**폴 루프(poll loop)**  

=> 카프카에서 메시지를 사용하는 첫 단계는 토픽의 구독  
=> 컨슈머 애플리케이션은 하나 이상의 토픽에 대해서 구독 부터 함  
=> 그 다음 애플리케이션은 레코드를 가져오기 위해 카프카 서버를 조사  
=> 이러한 반복 과정은 서버 조정, 레코드 획득, 파티션 리밸런스 ,컨슈머 하트비트 유지 등을 관리  

=> 메타데이터를 받은 컨슈머는 파티션에 할당된 해당 브로커에서 데이터를 가져오기 시작  
=> 새로운 레코드가 발견되면 레코드를 가져오고 역직렬화  
=> 레코드를 최종적으로 처리하고, 기본적인 데이터 유효성 검증을 하고 나면, 일종의 외부 저장소 시스템에  
저장  
=> 극히 일부의 경우에는 레코드를 런타임처리하고 외부 애플리케이션에 전달  
=> 최종적으로 컨슈머는 성공적으로 처리된 메시지 오프셋을 커밋

---  

<div id="컨슈머_API"></div>

> ### 카프카 컨슈머 API  

- 컨슈머 설정
- 카프카 컨슈머 객체
- 구독 및 폴링
- 커밋과 오프셋
- 추가 설정  

#### 컨슈머 설정  
;카프카 컨슈머를 생성하려면 몇 가지 필수 속성이 필요  

- **bootstrap.servers**  
; 카프카 브로커의 IP 주소 목록  
- **key.deserializer**  
; 키를 역직렬화 하기 위해 사용  
=> 프로듀서의 키 시리얼라이저와 대응되어야 함  
- **value.deserializer**  
; 메시지를 역직렬화 하기 위해 사용  
=> 시리얼라이저와 대응되여야 함  
- **group.id**  
=> 필수는 아니지만 사용을 권장  
=> APP 생성 시에 컨슈머 그룹을 정의하는 것은 필요에 따라 컨슈머를 관리하고  
성능을 향상시키는데 도움이 됨  

> Consumer example (java)  

```
import java.util.Properties;
import org.apache.kafka.clients.consumer.KafkaConsumer;

...

Properties consumerProperties = new Properties();
consumerProperties.put("bootstrap.servers", "");
consumerProperties.put("group.id", "Demo");
consumerProperties.put("key.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");
consumerProperties.put("value.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");

KafkaConsumer<String, String> consumer = new KafkaConsumer<>(consumerProperties);
```  

- Properties 객체 : 컨슈머 속성을 초기화 하는데 사용  
- Deserializer : 바이트 배열을 필요한 객체로 변환하는데 어떤 시리얼라이저 클래스가 사용되는지 알려줌  
- KafkaConsumer : 속성이 설정되면 컨슈머 객체를 생성할 수 있음  
=> 컨슈머 객체에 연결할 브로커 IP, 컨슈머가 속하게 될 그룹명, 사용할 역직렬화 클래스, 커밋하면서 사용 할  
오프셋 운영 방안을 알려줌  

#### 구독과 폴링  
; 컨슈머는 데이터를 받기 위해 토픽을 구독함.  

- public void subscribe(Collection<String> topics)  
; 등록을 원하는 토픽 이름의 목록을 전달  
=> 메시지 데이터 처리에 영향을 줄 수 있는 기본 리밸런서(default rebalancer)를 사용  
- public void subscribe(Pattern pattern, ConsumerRebalanceListener listener)  
; 카프카에 존재하는 적합한 토픽을 대응시키는 정규식을 사용 & 이는 동적으로 처리  
=> 정규식에 대응하는 새로운 토픽의 추가나 삭제 시에 리밸런서를 트리거함  
- public void subscribe(Collection<String> topics, ConsumerRebalanceListener listener)  
; 토픽의 목록을 전달하고 ConsumerRebalanceListener를 수반  

#### 커밋 처리와 폴링  














---  

<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
